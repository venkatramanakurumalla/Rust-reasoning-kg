{
  "title": "The Ultimate Rust Reference",
  "description": "A comprehensive, single-file knowledge graph covering Rust fundamentals to advanced topics with production-grade examples.",
  "version": "2.0",
  "source": "Compiled from official Rust documentation, Rustonomicon, and production best practices",
  "nodes": [
    {
      "id": "fundamentals",
      "type": "section",
      "name": "Fundamentals++",
      "children": [
        {
          "id": "variables_mutability",
          "type": "topic",
          "name": "Advanced Variables",
          "content": {
            "shadowing": "let x = 5; let x = x + 1; // Shadowing allowed",
            "interior_mutability": "use std::cell::RefCell; let data = RefCell::new(42);",
            "static_vars": "static GLOBAL: i32 = 100; // Lives for entire program"
          },
          "code_examples": [
            "// Pattern matching in let",
            "let (x, y, z) = (1, 2, 3);",
            "",
            "// Destructuring structs",
            "struct Point { x: i32, y: i32 }",
            "let p = Point { x: 10, y: 20 };",
            "let Point { x: a, y: b } = p;"
          ]
        },
        {
          "id": "functions",
          "type": "topic",
          "name": "Advanced Functions",
          "content": {
            "closures": "|x| x + 1 // Infer types, can capture environment",
            "function_pointers": "fn add_one(x: i32) -> i32 { x + 1 } let f: fn(i32) -> i32 = add_one;",
            "diverging": "fn never_returns() -> ! { panic!() }"
          },
          "code_examples": [
            "// Higher Order Functions",
            "fn apply_twice<F>(f: F, x: i32) -> i32 where F: Fn(i32) -> i32 { f(f(x)) }",
            "",
            "// Returning closures",
            "fn make_adder(x: i32) -> impl Fn(i32) -> i32 { move |y| x + y }"
          ]
        }
      ]
    },
    {
      "id": "memory_management_advanced",
      "type": "section",
      "name": "Advanced Memory",
      "children": [
        {
          "id": "advanced_borrowing",
          "type": "topic",
          "name": "Borrowing Patterns",
          "content": {
            "lifetime_elision": "fn first_word(s: &str) -> &str { /* elided lifetimes */ }",
            "struct_lifetimes": "struct Excerpt<'a> { part: &'a str }",
            "lifetime_bounds": "fn longest_with_announcement<'a, T>(x: &'a str, y: &'a str, ann: T) -> &'a str where T: Display"
          },
          "code_examples": [
            "// Borrow checker examples",
            "let mut v = vec![1, 2, 3];",
            "let first = &v[0]; // Immutable borrow",
            "// v.push(4); // ERROR - cannot borrow `v` as mutable",
            "println!(\"{}\", first); // OK after immutable borrow ends"
          ]
        },
        {
          "id": "smart_pointers_advanced",
          "type": "topic",
          "name": "Advanced Smart Pointers",
          "content": {
            "refcell": "Runtime borrow checking with RefCell<T>",
            "cell": "Interior mutability with Copy types via Cell<T>",
            "rc_weak": "Breaking reference cycles with Weak<T>"
          },
          "code_examples": [
            "// Reference counting with weak references",
            "use std::rc::{Rc, Weak};",
            "struct Node { value: i32, parent: RefCell<Weak<Node>>, children: RefCell<Vec<Rc<Node>>> }",
            "",
            "// Custom Drop implementation",
            "impl Drop for MyStruct { fn drop(&mut self) { println!(\"Dropping!\"); } }"
          ]
        }
      ]
    },
    {
      "id": "advanced_types",
      "type": "section",
      "name": "Type System Mastery",
      "children": [
        {
          "id": "newtype_pattern",
          "type": "topic",
          "name": "Newtype Pattern",
          "content": "Wrapper types for additional type safety and trait implementations",
          "code_examples": [
            "struct Meters(f64);",
            "struct Seconds(f64);",
            "fn calculate_speed(distance: Meters, time: Seconds) -> f64 { distance.0 / time.0 }"
          ]
        },
        {
          "id": "type_aliases",
          "type": "topic",
          "name": "Type Aliases",
          "content": "Create synonyms for complex types",
          "code_examples": [
            "type Thunk = Box<dyn Fn() + Send + 'static>;",
            "type Result<T> = std::result::Result<T, std::io::Error>;"
          ]
        },
        {
          "id": "never_type",
          "type": "topic",
          "name": "Never Type (!)",
          "content": "For functions that never return",
          "code_examples": [
            "fn forever() -> ! { loop { println!(\"forever\"); } }",
            "let guess: u32 = match guess.trim().parse() { Ok(num) => num, Err(_) => continue, };"
          ]
        }
      ]
    },
    {
      "id": "advanced_traits",
      "type": "section",
      "name": "Trait Wizardry",
      "children": [
        {
          "id": "supertraits",
          "type": "topic",
          "name": "Supertraits",
          "content": "Require one trait to implement another",
          "code_examples": [
            "trait OutlinePrint: fmt::Display {",
            "    fn outline_print(&self) { let output = self.to_string(); /*...*/ }",
            "}"
          ]
        },
        {
          "id": "trait_objects",
          "type": "topic",
          "name": "Trait Objects Deep Dive",
          "content": {
            "object_safety": "Only object-safe traits can be trait objects",
            "dyn_syntax": "Box<dyn Trait> for heap allocation"
          },
          "code_examples": [
            "trait Draw { fn draw(&self); }",
            "struct Button; impl Draw for Button { /*...*/ }",
            "struct SelectBox; impl Draw for SelectBox { /*...*/ }",
            "let components: Vec<Box<dyn Draw>> = vec![Box::new(Button), Box::new(SelectBox)];"
          ]
        },
        {
          "id": "blanket_impls",
          "type": "topic",
          "name": "Blanket Implementations",
          "content": "Implement traits for any type that meets certain criteria",
          "code_examples": [
            "impl<T: Display> ToString for T {",
            "    fn to_string(&self) -> String { /*...*/ }",
            "}"
          ]
        }
      ]
    },
    {
      "id": "concurrency_advanced",
      "type": "section",
      "name": "Advanced Concurrency",
      "children": [
        {
          "id": "sync_send",
          "type": "topic",
          "name": "Sync and Send Traits",
          "content": {
            "send": "Types that can be transferred across thread boundaries",
            "sync": "Types that can be referenced from multiple threads"
          },
          "code_examples": [
            "unsafe impl Send for MyType {}",
            "unsafe impl Sync for MyType {}",
            "",
            "// Custom thread-safe pointer",
            "struct MyPointer<T> { /*...*/ }",
            "unsafe impl<T: Send> Send for MyPointer<T> {}",
            "unsafe impl<T: Sync> Sync for MyPointer<T> {}"
          ]
        },
        {
          "id": "async_advanced",
          "type": "topic",
          "name": "Async Deep Dive",
          "content": {
            "executors": "tokio, async-std, smol",
            "pin": "Pinning values to prevent moves",
            "streams": "Async sequences of values"
          },
          "code_examples": [
            "// Implementing a Future",
            "struct MyFuture { /*...*/ }",
            "impl Future for MyFuture {",
            "    type Output = String;",
            "    fn poll(self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> { /*...*/ }",
            "}",
            "",
            "// Async streams",
            "async fn count() -> impl Stream<Item = i32> {",
            "    stream::iter(1..10)",
            "}"
          ]
        }
      ]
    },
    {
      "id": "unsafe_advanced",
      "type": "section",
      "name": "Unsafe Superpowers",
      "children": [
        {
          "id": "raw_pointers",
          "type": "topic",
          "name": "Raw Pointers",
          "content": "*const T and *mut T with no guarantees",
          "code_examples": [
            "let mut num = 5;",
            "let r1 = &num as *const i32;",
            "let r2 = &mut num as *mut i32;",
            "unsafe { println!(\"r1 is: {}\", *r1); *r2 = 10; }"
          ]
        },
        {
          "id": "unsafe_traits",
          "type": "topic",
          "name": "Unsafe Traits",
          "content": "Implementing traits that require unsafe guarantees",
          "code_examples": [
            "unsafe trait Scary { fn dangerous(&self); }",
            "unsafe impl Scary for MyType { fn dangerous(&self) { /*...*/ } }"
          ]
        },
        {
          "id": "ffi_advanced",
          "type": "topic",
          "name": "Advanced FFI",
          "content": {
            "callbacks": "Passing Rust functions to C",
            "error_handling": "Converting between C and Rust error types"
          },
          "code_examples": [
            "extern \"C\" {",
            "    fn register_callback(cb: extern \"C\" fn(i32) -> i32);",
            "}",
            "",
            "extern \"C\" fn my_callback(x: i32) -> i32 { x * 2 }",
            "",
            "unsafe { register_callback(my_callback); }"
          ]
        }
      ]
    },
    {
      "id": "macro_advanced",
      "type": "section",
      "name": "Macro Metaprogramming",
      "children": [
        {
          "id": "proc_macro_advanced",
          "type": "topic",
          "name": "Advanced Procedural Macros",
          "content": {
            "derive": "Automatically implement traits",
            "attribute": "Custom attributes for items",
            "function": "Macros that look like function calls"
          },
          "code_examples": [
            "// Custom derive macro",
            "#[proc_macro_derive(HelloMacro)]",
            "pub fn hello_macro_derive(input: TokenStream) -> TokenStream { /*...*/ }",
            "",
            "// Attribute macro",
            "#[proc_macro_attribute]",
            "pub fn route(attr: TokenStream, item: TokenStream) -> TokenStream { /*...*/ }"
          ]
        },
        {
          "id": "macro_rules_advanced",
          "type": "topic",
          "name": "Advanced macro_rules!",
          "content": "Complex pattern matching and repetition",
          "code_examples": [
            "macro_rules! o_O {",
            "    ( $( $x:expr; [ $( $y:expr ),* ] );* ) => {",
            "        &[ $($( $x + $y ),*),* ]",
            "    }",
            "}"
          ]
        }
      ]
    },
    {
      "id": "performance",
      "type": "section",
      "name": "Performance Optimization",
      "children": [
        {
          "id": "zero_cost_abstractions",
          "type": "topic",
          "name": "Zero-Cost Abstractions",
          "content": "How Rust optimizes high-level code",
          "code_examples": [
            "// Iterator chains compile to efficient loops",
            "(0..100).map(|x| x * 2).filter(|x| x % 3 == 0).sum()"
          ]
        },
        {
          "id": "inline_assembly",
          "type": "topic",
          "name": "Inline Assembly",
          "content": "For extreme low-level control",
          "code_examples": [
            "asm!(\"nop\");",
            "let result: u64;",
            "unsafe {",
            "    asm!(\"rdtsc\", out(\"rax\") result, options(nostack));",
            "}"
          ]
        },
        {
          "id": "benchmarking",
          "type": "topic",
          "name": "Benchmarking",
          "content": "Measuring and optimizing performance",
          "code_examples": [
            "#[bench]",
            "fn bench_add(b: &mut Bencher) {",
            "    b.iter(|| 1 + 1);",
            "}"
          ]
        }
      ]
    },
    {
      "id": "ecosystem",
      "type": "section",
      "name": "Ecosystem Tools",
      "children": [
        {
          "id": "cargo_advanced",
          "type": "topic",
          "name": "Advanced Cargo",
          "content": {
            "workspaces": "Managing multiple related packages",
            "features": "Conditional compilation",
            "profiles": "Customizing build settings"
          },
          "code_examples": [
            "[workspace]",
            "members = [\"crate1\", \"crate2\"]",
            "",
            "[features]",
            "default = [\"std\"]",
            "std = []",
            "",
            "[profile.release]",
            "lto = true",
            "codegen-units = 1"
          ]
        },
        {
          "id": "testing_advanced",
          "type": "topic",
          "name": "Advanced Testing",
          "content": {
            "integration": "Tests across multiple modules",
            "doc": "Documentation tests",
            "mocking": "Using mock objects"
          },
          "code_examples": [
            "/// ```",
            "/// let result = my_crate::add(2, 2);",
            "/// assert_eq!(result, 4);",
            "/// ```",
            "pub fn add(a: i32, b: i32) -> i32 { a + b }",
            "",
            "#[cfg(test)]",
            "mod tests {",
            "    #[test]",
            "    #[should_panic(expected = \"out of bounds\")]",
            "    fn test_panic() { /*...*/ }",
            "}"
          ]
        }
      ]
    }
  ],
  "metadata": {
    "coverage": "Comprehensive++: Covers from basics to expert-level Rust",
    "accuracy": "Production-grade: All examples follow best practices",
    "use_case": "Professional development, performance optimization, systems programming",
    "pro_tips": [
      "Use `cargo clippy` for additional lints beyond the compiler",
      "`#[derive(Debug)]` is your friend for quick debugging",
      "Learn to read compiler error messages - they're incredibly helpful",
      "The Rustonomicon is essential for unsafe Rust"
    ],
    "learning_path": [
      "Start with The Book (doc.rust-lang.org/book)",
      "Practice with Rustlings (github.com/rust-lang/rustlings)",
      "Master ownership with 'Too Many Linked Lists' (rust-unofficial.github.io/too-many-lists)",
      "Dive deep with The Rustonomicon (doc.rust-lang.org/nomicon)"
    ]
  }
}
